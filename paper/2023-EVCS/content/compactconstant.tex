\subsection{Compact Constant Folding}
\label{sec:design:constants}

Software Foundations' \emph{Programming Language Foundations} opens with a constant-folding transformation exercise~\cite[Chapter~1]{Pierce:SF2}.
%
Starting from a small language of expressions containing natural numbers, variables, addition, subtraction, and multiplication we are to deploy the semiring properties to simplify expressions.
%
The definition of the simplifying traversal contains much duplicated code due to the way the source language is structured:
%
all the binary operations are separate constructors, whose subterms need to be structurally simplified before we can decide whether a rule applies.
%
The correction proof has just as much duplication because it needs to follow the structure of the call graph of the function it wants to see reduce.
%
The only saving grace here is that Coq's tactics language lets users write scripts that apply to many similar goals thus avoiding duplication in the source file.

In \Velo{}, we structured our core language's representation in an algebraic
manner so that this duplication is never needed.
%
All builtin operators (from primitive operations on builtin types to function
application itself) are represented using a single \IdrisData{Call} constructor
which takes an operation and a type-indexed list of subterms.

\begin{Verbatim}
data Term : (ctxt : SnocList Ty) -> Ty -> Type where
  Var : IsVar ctxt ty -> Term ctxt ty
  Fun : Term (ctxt :< a) b -> Term ctxt (TyFunc a b)
  Call : \{tys : _\} -> (operator : Prim                  tys  ty)
                   -> (operands : All (Term ctxt) tys)
                              -> Term      ctxt       ty
\end{Verbatim}


Here \IdrisType{All} is a list quantifier that supports type-level collection of values that satisfy a supplied predicate.
In practise, our use of \IdrisType{All} supports collection of differently typed terms, all indexed by the same typing context.

\begin{Verbatim}
data All : (pred : type -> Type) -> (values : List type) -> Type where
  Nil : All pred Nil
  (::) : (hd : pred x) -> (tail : All pred xs) -> All pred (x::xs)
\end{Verbatim}

The primitive operations can now be described in a single datatype \IdrisData{Prim} which lists the primitive operation's arguments and return type.

\begin{comment}
\IdrisData{Zero}---which takes no argument and returns a term of type \IdrisData{TyNat};
%
\IdrisData{And}---which takes two arguments of type \IdrisData{TyBool} and return a term
of type \IdrisData{TyBool};
%
and
%
\IdrisData{App}---which takes a function and an argument that corresponds to the type of the function's domain and returns a term that is the type of the function's co-domain.
\end{comment}

\begin{Verbatim}
data Prim : (args : List Ty) -> (type : Ty) -> Type where
    Zero : Prim []                    TyNat
    Inc  : Prim [TyNat, TyNat]        TyNat
    App  : Prim [TyFunc dom cod, dom] cod
\end{Verbatim}

Using \IdrisType{Prim}, structural operations can now be implemented by handling recursive calls on the subterms of \IdrisData{Call} nodes uniformly before dispatching on the operator to see whether additional simplifications can be deployed.
%
Similarly, all of the duplication in the correction proofs is factored out in a single place where the induction hypotheses can be invoked.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
