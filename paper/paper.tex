\documentclass[%
draft,
a4paper,
UKenglish,
cleveref,
autoref,
thm-restate,
%anonymous,
pdfa
]{oasics-v2021}

\usepackage{acronym}
\usepackage{xspace}
\usepackage[commandnameprefix=always]{changes}

\pdfoutput=1
\hideOASIcs %uncomment to remove references to OASIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Type Theory as a Language Workbench} %TODO Please add

\author
{Jan {de Muijnck-Hughes}}
{University of Glasgow, UK}
{Jan.deMuijnck-Hughes@glasgow.ac.uk}
{https://orcid.org/0000-0003-2185-8543}
{} % TODO

\author
{Guillaume Allais}
{University of St Andrews, UK}
{gxa1@st-andrews.ac.uk} % Check
{https://orcid.org/0000-0002-4091-657X} % ORCID
{} % TODO

\author
{Edwin Brady}
{University of St Andrews, UK}
{ecb10@st-andrews.ac.uk} % Check
{} % ORCID
{} % TODO

% TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\authorrunning{J. {de Muijnck-Hughes} and Guillaume Allais and Edwin Brady}
% TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jan de Muijnck-Hughes and Guillaume Allais and Edwin Brady}
% TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}}
% TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\keywords{Dummy keyword}
% TODO mandatory; please add comma-separated list of keywords

\category{}
% optional, e.g. invited paper

\relatedversion{}

% \supplement{}
% optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
% \supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version}
% linktext, cite, and subcategory are optional

% \funding{(Optional) general funding statement \dots}
% optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% \acknowledgements{I want to thank \dots}
% optional

%\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\acrodef{dsl}[DSL]{Domain Specific Language}
\acrodef{edsl}[EDSL]{Embedded Domain Specific Language}
\acrodef{stlc}[STLC]{Simply-Typed Lambda Calculus}

\definechangesauthor[color=orange,name={Jan}]{jfdm}
\definechangesauthor[color=green, name={Guillaume}]{gallais}
\definechangesauthor[color=red, name={Edwin}]{edwin}

\newcommand{\Velo}{V{\'e}lo\xspace}

\begin{document}

\maketitle

% 1. State the problem
% 2. Say why it is an interesting problem
% 3. Say what your solution achieves
% 4. Say what follows from your solution

\begin{abstract}
We are planning to showcase dependently typed techniques to implement \& manipulate IRs.

The key components we are planning to treat are:

\begin{itemize}
\item Efficient de Bruijn representations
\item Co de Bruijn for CSE
\item Evaluation as Progress (with computation rules in one separate function)
\item Well scoped holes
\item Linear (in number of cases) decidable equality
\item Compact constant folding
\item Positive evidence for negative statements
\item Whole pipeline (parser, elaborator, REPL, evaluator, compiler passes)
\end{itemize}

Our ongoing work is available at:

\url{https://github.com/jfdm/velo-lang}
\end{abstract}

\section{Introduction}
\label{sec:introduction}

A \emph{Language Workbench} offers language designers an expressive environment in which to design and implement their \Acp{dsl}.
\chcomment[id=jfdm]{Needs extending.}

Dependently-typed languages such as Idris~\cite{DBLP:conf/ecoop/Brady21} provides programmers with an expressive environment in which to reason not only about their software programs but more importantly about the \emph{programming languages} in which we write our programs.
There is a plethora of work attesting to the ability of dependent-types to reason about the programming languages we all use, and textbooks such as \emph{Programming Language Foundations in Agda}~\cite{plfa22.08} and \emph{Software Foundations}~\cite{Pierce:SF2} detail how others can learn to develop mechanised formal descriptions of their languages.
\chcomment[id=jfdm]{Needs extending.}

The formal design of a programming language is, however, just one aspect of he language's lifecycle.
Programming languages are also to be used.
Dependently-typed languages such as Idris also supports the efficient execution of our `reasoned about' software programmes and the programming languages described.
\chcomment[id=jfdm]{Needs extending.}

This paper presents \Velo{} a minimal functional language based on the \ac{stlc} combined with an extended form of \emph{Hutton's Razor} that show cases how we can use languages, such as Idris, as a language workbench.
\chcomment[id=jfdm]{Needs extending.}
% C-c C-a ?todo

\section{Introducing Velo}
\label{sec:velo}

\chcomment{Whole pipeline (parser, elaborator, REPL, evaluator, compiler passes)}


\section{Language Design}
\label{sec:design}

\chcomment{Efficient De Bruijn Representation}
\chcomment{Compact constant folding}
\chcomment{Well-Typed Holes}

\section{Optimisation \& Execution}
\label{sec:compiler}


\chcomment{Co de Bruijn for CSE}
\chcomment{Evaluation as Progress (with computation rules in one separate function)}

\section{Good Programming Idioms}
\label{sec:idioms}

Within \Velo{} there are two programming idioms that helped with the reporting of errors, and efficiency of deciding equality.

\subsection{Being Positively Negative}
\label{sec:idioms:posneg}

A workhorse of dependently typed programming is using decidable predicates capture, and produce, positive information.
We can represent the results of a decidable function using \texttt{Dec}:

\begin{verbatim}
data Dec a = Yes a | No (a -> Void)
\end{verbatim}

\noindent
Notice that in the negative position (the \texttt{No} constructor) we do not return positive information.
Wee provide a proof of falsity.
When reasoning about our programs such proof of falsity is good.
When interacting with our programs such proof of falsity is not good.
Consider the following type signatures that specify two decidable procedures.
The first to determine if one natural number is greater than another.

\begin{verbatim}
isGT : (x,y : Nat) -> Dec (GT x y)
\end{verbatim}

\noindent
And the other, to determine if any element in the list satisfies a supplied predicate.

\begin{verbatim}
any : (f  : (x : type) -> Dec (p x)) -> (xs : List type) -> Dec (Any p xs)
\end{verbatim}

For \texttt{isGT} we know that if the result is negative we can safely assume that \texttt{GT x y} is false.
With \texttt{any} we do not know for sure why the decidable procedure failed.
Was it because the list was empty?
or,
was it because all elements of \texttt{xs} did not satisfy \texttt{p}!?
More so what was the reason for any element in \texttt{xs} for not satisfying \texttt{p}?

To address these issues. we introduce \texttt{DecInfo} a variant of \texttt{Dec} that carries positive information in the negative case, as well as proofs-of-falsity.

\begin{verbatim}
data DecInfo e p = Yes p | No e (p -> Void)
\end{verbatim}

With this simple change we can now report \emph{why} a decision procedure failed, as well as proof that it failed.
Our examples can now become:

\begin{verbatim}
isGT : (x,y : Nat) -> DecInfo (LTE x y) (GT x y)
\end{verbatim}

\noindent
and

\begin{verbatim}
any : (f  : (x : type) -> Dec (q x) (p x))
   -> (xs : List type)
         -> DecInfo (All (\x => Pair (q x) (Not (p x))) xs) (Any p xs)
\end{verbatim}

\texttt{DecInfo} is, however, not strictly positive as it carries a proof of false.
A more interesting line of work would be to adopt \emph{constructive negation} to ensure that proofs of false arise from positive sources only~\cite{msfp/Atkey22}.
That is, given:

\begin{verbatim}
Predicate : Type -> Type -> Type
Predicate pos neg = (pos ** neg ** (pos -> neg -> Void))
\end{verbatim}

we can recreate \texttt{DecInfo} as:


\begin{verbatim}
Dec : Predicate -> Type
Dec (pos ** neg ** no) = Either neg pos
\end{verbatim}

This is line of investigation is on going.

\subsection{Efficient Decidable Equality}
\label{sec:idioms:decEq}


\chcomment{Linear (in number of cases) decidable equality}

Creating a decidable equality instance (\texttt{DecEq}) over a data structure requires pairwise comparison over the structure.
Although we can already reduce the number of contraditions using symmetry breaking (\texttt{negEqSym}), the number of cases is still many.
We can address the complexity of \texttt{decEq} instance creation further computing a diagonal relation that ensures we are comparing the same constructors.

\chcomment[id=jfdm]{The example is probably not needed, but useful to have...}

\begin{verbatim}
data Thing = Apples | Oranges

data Diag : (x,y : Thing) -> Type where
  A : Diag Apples Apples
  O : Diag Oranges Oranges

diag : (x,y : Thing) -> Maybe (Diag x y)
diag Apples Apples = pure A
diag Oranges Oranges = pure O
diag _ _ = Nothing

diagNot : (x : Thing) -> Not (diag x x === Nothing)
diagNot Apples Refl impossible
diagNot Oranges Refl impossible

diagEq : Diag x y -> Dec (x === y)
diagEq A = Yes Refl
diagEq O = Yes Refl

decEq : (x,y : Thing) -> Dec ( x === y)
decEq x y with (diag x y) proof sim
  decEq x y | Nothing = No (\Refl => diagNot _ sim)
  decEq x y | (Just prf) = diagEq prf
\end{verbatim}

\section{Conclusion}
\label{sec:conclusion}


\bibliography{paper}

\end{document}
