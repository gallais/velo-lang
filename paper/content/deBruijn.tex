\subsection{Efficient De Bruijn Representation}
\label{sec:design:deBruijn}

A common strategy for implementing well-scoped terms is to use typed
\emph{De Bruijn} indices~\cite{MANUAL:journals/math/debruijn72}, and these indices can be easily realised as an inductive family~\cite{DBLP:journals/fac/Dybjer94}
indicating where in the type-level context the variable is bound.

Concretely, we index the \IdrisType{Elem} family by the kind of the variable it represents and a \IdrisType{SnocList} of kinds as the context to reflect the fact that,
in inference rules, the most local end of the context is always on the right hand side.

\begin{verbatim}
data Elem : (ty : kind) -> (ctxt : SnocList kind) -> Type
  where
    Here : Elem ty (ctxt :< ty)
    There : Elem ty ctxt -> Elem ty (ctxt :< not_ty)
\end{verbatim}

The \IdrisData{Here} constructor indicates that the variable of interest is
the most local one in scope.
%
The \IdrisData{There} constructor skips past the most local one to look for
the variable of interest in the rest of the context.

Whilst a valid definition, this approach unfortunately does not scale to
large contexts: every \IdrisType{Elem} proof is linear in the size of the de Bruijn
index that it represents.
%
To improve the runtime efficiency of the representation we instead opt to
model de Bruijn indices as natural numbers, which Idris 2 will compile to
GMP-style unbounded integers.
%
Further, we need to additionally define an \IdrisType{AtIndex} family to ensure that
all of the natural numbers we use correspond to valid indices.
%
We pointedly reuse the \IdrisType{Elem} names because these \IdrisData{Here}
and \IdrisData{There} play exactly the same role.

\begin{verbatim}
data AtIndex : (ty : kind) -> (ctxt : SnocList kind) -> (idx : Nat) -> Type
  where
    Here : AtIndex ty (ctxt :< ty) Z
    There : (later : AtIndex ty  ctxt               idx)
                  -> AtIndex ty (ctxt :< not_ty) (S idx)
\end{verbatim}

\noindent
We then define a variable as the pairing of a natural number and an \emph{erased}
proof that the given natural numbers is indeed a valid de~Bruijn index.

\begin{verbatim}
data IsVar : (ctxt : SnocList kind) -> (ty : kind) -> Type
  where
    V : (idx : Nat) -> (0 prf : AtIndex ty ctxt idx) -> IsVar ctxt ty
\end{verbatim}

We now have the best of both worlds: a well-scoped realisation of de~Bruijn indices
that is guaranteed to be compiled efficiently.

\todo{Talk about smart constructors \& views?}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
