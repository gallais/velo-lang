\chcomment{Whole pipeline (parser, elaborator, REPL, evaluator, compiler passes)}

The design behind \Velo{} is purposefully unsurprising:
%
it is \emph{just} the \ac{stlc} extended with booleans and natural numbers with binary conjunction and addition operations as primitives.
%
To promote the idea of interactive editing \Velo{} also supports well-typed holes.
%
Below we show an example \Velo{} program, and an extract from the \acs*{repl} session that list's the current set of holes.

\begin{center}
  \begin{minipage}[t]{0.45\linewidth}
\begin{Verbatim}
   let b = false
in let double
         = (fun x : nat
              => (add x x))
in let x = (double ?hole)
in         (double ?hole)
\end{Verbatim}
\end{minipage}
\hfill
  \begin{minipage}[t]{0.45\linewidth}
    \begin{Verbatim}
Velo> :holes
b : Bool
double : Nat -> Nat
----------
?hole : Nat
\end{Verbatim}
\end{minipage}

\end{center}

The \emph{featherweight} language design of \Velo{} helps us to showcase better how we can use dependently-typed languages as language workbenches.

\jfdm{Do we need to evidence (through citation) benefits of featherweight languages?}

\Velo{} is as a \emph{complete} language with a standard compiler pipeline, and REPL. % there is \ac{repl} if we need it.
%
A \ac{dsl} captures the language's concrete syntax, and a parser turns \ac{dsl} instances into raw unchecked terms.
%
Bidirectional type checking elaborates these raw terms into a set of well-typed \acp{ir}:
%
\IdrisType{Holey} supports well-scoped typed holes;
%
and
%
\IdrisType{Terms} our core representation that captures our language's abstract syntax.
%
We present the interesting aspect of our \ac{ir} design in \Cref{sec:design:holes}.
%
Further, elaboration performs standard syntax transformations that turns let-bindings into function application.
%
From the core representation we also provide well-scoped \ac{cse} using co-\DeBruijn{} indexing (\Cref{sec:compiler-pass}), and we provide a verified evaluator to reduce terms to values (\Cref{sec:semantics}).

A key tenet in language workbenches, such as Spoofax, is the \emph{ease} at which language's can be created.
To that same degree, we have also sought to develop a series of reusable modules that captures functionality common to many languages.
Thus reducing the \emph{boilerplate} required when creating \acp{edsl} in \Idris{}.


\jfdm{Would it be good to show an example high-level trace of the output?}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
